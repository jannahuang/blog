# [实现 JS Formatter](https://github.com/jannahuang/blog/issues/10)

# JS Formatter 是什么
JS Formatter 是可以对 JavaScript 代码进行格式化的工具，可参考 WebStorm 的配置 Preferences -> Editor -> Code Style -> JavaScript 实现加减空格、缩进和分号的功能。

# 步骤拆解
本项目技术方案采用 Vue3 + ElementPlus + highlightjs + espree + Webpack。
拆解思维导图如下：
![formatter 步骤拆解](https://raw.githubusercontent.com/jannahuang/blog/main/pictures/formatter%20%E6%AD%A5%E9%AA%A4%E6%8B%86%E8%A7%A3.png)
接下来按步骤实现代码。

# 代码实现
## parse()：提取 AST
使用 espree.parse() 提取 AST。
```javascript
    const parse = (code) => {
        let ast = espree.parse(code, {
            ecmaVersion: "latest",
            // 指定要解析的脚本类型（“script”、“module”或“commonjs”）
            sourceType: "module",
            range: true,
            comments: true,
            attachComment: true,
            tokens: true,
            tolerant: true,
            ecmaFeatures: {
                // 启用 JSX 解析
                jsx: true,
                globalReturn: true
            }
        })
        return ast
    }
```
根据 espree 官方说明配置，适用于本次格式化的源码（使用 WebStorm 的示例代码）。

## getConfig()：获取当前勾选的格式化配置
使用 ElementPlus 的 ElCheckboxGroup 和 ElCheckbox 组件，用 checkList 获取当前配置。

## codeGen()：生成格式化后的代码
此处需用到 https://astexplorer.net/，便于观察生成的 AST 抽象语法树。
先举个简单的例子，取待格式化的第一行代码进行演示。
```javascript
import {Component} from 'react'
```
将上述代码粘贴到 astexplorer 左边输入框，上方语言选 JavaScript，解析器选 espree，右边生成的即是左边代码对应的 AST tree。
![astexplorer.net](https://raw.githubusercontent.com/jannahuang/blog/main/pictures/ast.png)
将鼠标移到左边代码上，右边 AST tree 会高亮显示对应的节点。我们需要遍历这些节点，对其进行相应处理，并返回新的代码字符串，这个过程即实现格式化。
而需要生成怎样的字符串呢？这时可以去上方所说的 WebStorm 配置里，勾选对应的格式化配置，观察格式化后的代码。
格式化前：
![no_es6_import/export_braces](https://raw.githubusercontent.com/jannahuang/blog/main/pictures/no_es6_import:export_braces.png)
格式化后：
![no_es6_import/export_braces](https://raw.githubusercontent.com/jannahuang/blog/main/pictures/es6_import:export_braces.png)
可见格式化后的代码，在花括号内两边增加了空格。那么如何用代码实现呢？
```javascript
const codeGen = (node) => {
    let type = node.type
    if (type === 'Program') {
      let body = node.body
      let s = body.map(b => codeGen(b)).join('\n')
      return s
    }
}
```
将 parse() 生成的 AST 传入 codeGen()，由上述 astexplorer 中所见，可以用 node.type 来判断当前节点。整个 AST 开始的节点是 'Program'，而我们需要获取的是 body 中的内容，所以递归调用 codeGen() 传入 body，而 body 是数组结构，所以用上述 map 写法调用。
第一次递归调用时，判断到当前 type 为'ImportDeclaration'，在该节点 AST 中可见，需要用到 specifiers 和 source 节点，分别对应了源代码的 {Component} 和 'react' 部分。我们需要获取这两个值。
```javascript
const codeGen = (node) => {
    let type = node.type
    if (type === 'Program') {
      let body = node.body
      let s = body.map(b => codeGen(b)).join('\n')
      return s
    } else if (type === 'ImportDeclaration') {
      let specifiers = node.specifiers
      let source = node.source
      // 引入用逗号分隔，所以返回结果 join(',')
      let s = specifiers.map(s => codeGen(s)).join(', ')
      let v = codeGen(source)
      // 检查是否勾选对应选项
      let es6_import_or_export_braces_space = toggleSpace('es6_import_or_export_braces')
      // 拼接返回内容
      let r = `import {${es6_import_or_export_braces_space}${s}${es6_import_or_export_braces_space}} from ${v}`
      return r
    }
}
```
而 specifiers 和 source 里还有其他节点，所以需要继续递归调用 codeGen()，同理 specifiers 是数组结构，用 map 调用，返回值用逗号拼接即可。
然后，需要检查当前是否勾选 es6_import_or_export_braces_space，有勾选则返回空格，没有则返回空。
由上述格式化图片可见，我们需要生成 import { Component } from 'react' 这段字符串，所以返回的拼接内容即 r 变量所示。
接下来，则是继续递归调用 codeGen() 以获取所需值。
```javascript
...
    else if (type === 'ImportSpecifier') {
      let imported = node.imported
      let name = codeGen(imported)
      return name
    } else if (type === 'Identifier') {
        return node.name
    } else if (type === 'Literal') {
        return node.raw
    }
...
```
当遍历到 type 为 Identifier 和 Literal 时，即可获取所需值。此时即可生成格式化后的字符串。
其他源代码处理逻辑同上。待补充。
将格式化后的代码显示在面板中即可。